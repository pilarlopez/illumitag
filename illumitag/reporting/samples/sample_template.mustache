Sample "{{sample_short_name}}"
==============================

General Information
-------------------
This sample has the code "{{sample_short_name}}" and is named "{{sample_long_name}}". It is part of the project code "{{project_short_name}}" ("{{project_long_name}}") along with {{project_other_samples}} other samples.

-------

Meta-data details
-----------------
The JSON file located online at:

> <{{json_url}}>

contains all the metadata associated with this sample. Here are the contents of this file:

    {{json_content}}

-------

Processing
----------
This report (and all the analysis) was generated using the ILLUMITAG project at:

> <http://github.com/limno/illumitag>

Version `{{illumitag_version}}` of the pipeline was used. The exact git hash of the latest commit was:

    {{git_hash}}

also refereed to by its tag `{{git_tag}}`. This document was generated at `{{now}}`.

A brief overview of what happens to the data can be viewed online here:

> <https://github.com/limno/illumitag/blob/master/documentation/pipeline_outline.pdf?raw=true>

The results and all the files generated for this sample can be found on UPPMAX at:

    {{results_directory}}

-------

Raw data
--------
* The forward read file weighed *{{fwd_size}}* and contained *{{fwd_count}}* reads with an average PHRED quality of *{{fwd_qual}}*
* The reverse read file weighed *{{rev_size}}* and contained *{{rev_count}}* reads with an average PHRED quality of *{{rev_qual}}*

More information about the raw output of the sequencer for this sample can be found in the HTML report generated by the Illumina software here:

    {{illumina_report}}

The average quality per base can be seen in figure \ref{per_base_qual} and the average quality per sequence in figure \ref{per_seq_qual}.

{{per_base_qual}}

{{per_seq_qual}}

-------

Joining
--------
The first step in processing is joining the forward and reverse reads together. This is done with a program called "PandaSeq". Exactly {{assembled_count}} reads were joined, {{unassembled_count}} where unable to be joined and {{low_qual_count}} were deemed of too low quality by the algorithm. The size of the overlapping region varies for every read, hence a distribution of sequence lengths is produced after is step and can be seen in figure \ref{assemlby_len_dist}. In addition, you can see the per base quality of the joined reads in figure \ref{joined_per_base_qual} and the per sequence quality in figure \ref{joined_per_seq_qual}.

{{assemlby_len_dist}}

{{joined_quality}}

-------

Filtering
---------
Next, we filter the sequences based on several criteria. These many sequences are lost:

* Checking for the presence of both primers at their exact positions with at most {{mismatches_allowed}} mismatches allowed discards {{primer_discard}} sequences ({{primer_left}} left).
* Checking for the absence of undetermined bases ("N" nucleotides) discards {{n_base_discard}} sequences ({{n_base_left}} left).
* Running a {{window_size}} base pair window over the sequences and checking that quality doesn't drop below {{window_threshold}} discards {{window_discard}} sequences ({{window_left}} left).
* Checking that no sequence is shorter than {{length_threshold}} base pairs discards {{length_discard}} sequences ({{length_left}} left).

This leaves us with {{percent_remaining}} of the original sequences. The next step in the pipeline is generating outputs that are compatible with "Qiime" and "Mothur" for those who are interested in that. We will also trim the primers on both ends of sequences.

Taxonomy
--------
Further analysis is usually performed not at the single sample level but on a bunch of samples at the same time (samples are grouped into projects), so you should go see the corresponding project report now. This will include OTU clustering, taxonomic assignment and more filtering. Nonetheless we can present some of the results from that analysis here.
